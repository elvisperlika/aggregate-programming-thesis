\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}
\usepackage{float}

\school{\unibo}
\programme{Corso di Laurea in Ingegneria e Scienze Informatiche}
\title{Eterogeneità dei sistemi di Aggregate Programming: estensione del sistema ScaFi per l'uso di robot Thymio}
\author{Elvis Perlika}
\date{\today}
\subject{Objective Oriented Programming}
\supervisor{Chiar.mo Prof. Mirko Viroli}
\cosupervisor{Dott. Gianluca Aguzzi}
\session{III}
\academicyear{2023-2024}

% Definition of acronyms
\acrodef{IoT}{Internet of Thing}
\acrodef{vm}[VM]{Virtual Machine}
\acrodef{FP}{Functional Programming}
\acrodef{RT}{Referential Transparency}
\acrodef{AP}{Aggregate Programming}
\acrodef{OOP}{Objective Oriented Programming}
\acrodef{AC}{Aggregate Computing}
\acrodef{TDM}{Thymio Device Manager}

\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
Massimo 2000 caratteri.
\end{abstract}

\begin{dedication} % this is optional
    Qualsiasi tecnologia sufficientemente avanzata è indistinguibile dalla magia. \\ Terza Legge di Arthur C. Clarke
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduzione}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

Intro.

\paragraph{Struttura della tesi}

%----------------------------------------------------------------------------------------
\chapter{Background}
\label{chap:background}
%----------------------------------------------------------------------------------------

% I suggest referencing stuff as follows: \cref{fig:random-image} or \Cref{fig:random-image}

% \begin{figure}
%     \centering
%     \includegraphics[width=.8\linewidth]{figures/random-image.pdf}
%     \caption{Some random image}
%     \label{fig:random-image}
% \end{figure}


\section{Paradigma dell'Aggregate Programming}

\subsection{Evoluzione dei paradigmi di programmazione}

L'Objective Oriented Programming è un paradigma nel senso stretto del termine poiché rappresenta un modo di organizzare e rappresentare un mondo. 
Il paradigma in questione deve la sua potenza nella capacità di simulare entità reali ed è riassumibile con la frase \textit{Everything is an Object}. 
È rilevante parlare di OOP in quanto il paradigma di programmazione funzionale, che è alla base di ScaFi, è un'estensione di esso. 
Il potere della programmazione ad Oggetti (OOP), come detto precedentemente, risiede nella capacità di simulare un mondo e permette di farlo grazie agli ``oggetti'', essi sono istanze di Classi, le quali a loro volta sono strutture dati astratte che permettono ad ogni loro istanza di avere uno stato (definito dai \textit{fields}) e un comportamento (definito dai \textit{methods}).
I pilastri della programmazione ad oggetti sono l'incapsulamento, l'ereditarietà e il polimorfismo.

Il difetto della programmazione ad oggetti è che richiede un particolare impegno nel gestire il sistema da realizzare all'aumentare della sua complessità. Altri paradigmi, come la programmazione funzionale, possono essere più adatti a determinati problemi.

Nel caso della OOP abbiamo riassunto il paradigma con la frase \textit{``Everything is an Object''}, per la programmazione funzionale possiamo riassumerla con \textit{``Everything is a Function''}. Quando si parla di funzioni nel ambito della \ac{FP} si intendo \textbf{funzioni pure}\cite{Hunt2018} cioè senza effetti collaterali. Per effetti collaterali si intende che la funzione fa altro oltre a restituire un risultato. Un paio di esempi, presi da \texttt{Functional Programming in Scala}, sono:

\begin{itemize}
    \item Modifica di una variabile
    \item Modifica del campo di un oggetto
    \item Leggere da o scrivere su un file
    \item ``Disegnare'' sullo schermo
\end{itemize}

Si potrebbe pensare che con l'uso della \ac{FP} si possano costruire solo programmi semplice, nella realtà non c'é alcuna limitazione sulla complessità del software da costruire poiché il paradigma della FP esprime un nuovo modo di pensare e scrivere il codice.

\label{sec:fp}
Nel dettaglio, per \textbf{funzione pura} si intende una funzione $f:A\to B$, (una funzione che prende un input di tipo $A$ e restituisce un output di tipo $B$) che mette in relazione ogni elemento di $A$ con esattamente un valore di $B$. Qualsiasi altra operazione che non sia utile a calcolare $f(a)=b$ con $a\in A$ e $b\in B$ deve essere intesa come effetto collaterale della funzione e quindi evitata se si vuole creare una funzione pura.

Un esempio di funzione pura, senza effetti collaterali, è la funzione di somma che prende in input due valori e ne restituisce la loro somma \cref{lst:sum-function}. 

\begin{lstlisting}[language=Scala, label={lst:sum-function}, caption={Esempio di funzione pura in Scala}]
    def sum(a: Int, b: Int): Int = a + b
\end{lstlisting}

Un esempio di funzione non pura, con effetti collaterali, è la funzione che prende in input un valore e lo stampa a schermo \cref{lst:print-function}.

\begin{lstlisting}[language=Scala, label={lst:print-function}, caption={Esempio di funzione non pura in Scala}]
    def print(a: Int): Unit = println(a)
\end{lstlisting}

Formalmente si può definire una funzione pura con il concetto di \ac{RT}\cite{Hunt2018}:

\begin{quote}
    Una funzione $f$ è Referentially Transparent se per ogni contesto $C$ nel quale la funzione viene inserita, essa può essere sostituta dal risultato della stessa funzione $f$ senza condizionare il risultato di $C$.
\end{quote}

È proprio questa proprietà che permette ad un programma progettato con approccio funzionale di essere maggiormente scalabile e mantenibile.

\subsection{Sistemi collettivi ed eterogenei} 

Per comprendere il potenziale del paradigma dell'\ac{AP} è fondamentale definire quale tipo di problema si vuole risolvere. La crescita del mondo \ac{IoT} ha portato alla presenza di numerosi dispositivi connessi tra loro di ogni tipo e caratterizzati da protocolli di comunicazione eterogenei. Il mondo dell'IoT in continua evoluzione promette di migliore la produzione, gli spazi di lavoro e la sanità attraverso la raccolta e l'analisi di grandi quantità di dati. È nato di conseguenza il bisogno di progettare sistemi resistenti e resilienti che permettessero di gestire queste grandi quantità di dispositivi. È necessario che questi sistemi siano capaci di: adattarsi a cambiamenti imprevedibili, permettere l'implementazione di nuovi comportamenti, permettere una capacità di rilevazione e attuazione nel ambiente in modo distribuito e coordinato. Allo stato attuale della tecnologia è difficile progettare sistemi di questo tipo poiché non esistono framework che permettano di gestire in modo semplice e intuitivo la complessità di questi sistemi \cite{Beal2015} \cite{CasadeiPhDThesis}.

Un'astrazione grafico del mondo IoT è presente in \cref{fig:iot-arc} \cite{Testa2022}. È possibile comprendere come ci sia uno strato contente i nodi (dispositivi)\footnote{HMI: Human-Machine-Interaction.}, uno strato che rappresenta la rete (internet) mediante la quale comunicano\footnote{Prima di accedere alla rete internet le informazioni dei sensori vengono raccolte dai Edge Gateway che si occupano di instradare le informazioni.} ed uno strato contente il mondo Cloud dove vengono raccolte tutte le informazioni prodotte dai nodi della rete e computate attraverso applicazioni complesse per l'analisi, la pianificazione, l'ottimizzazione ed altri scopi.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/iot-arc.png}
    \caption{Architettura del mondo IoT}
    \label{fig:iot-arc}
\end{figure}

Il problema di questa architettura è che inviare queste ingenti quantità di dati da un numero elevato di nodi può avere effetti negati sui costi, le disponibilità, la scalabilità e la latenza delle comunicazioni. Una delle soluzione trovate è quella di spostare la computazione più vicino possibile ai nodi della rete, in modo da ridurre la quantità di dati da inviare e la latenza delle comunicazioni. Questo approccio è chiamato \textit{Edge Computing} non è sempre conveniente applicarlo, dipende dal contesto (non sarebbe adatto nel caso i nodi abbiamo specifiche tecniche, come memoria e capacità di calcolo, deboli) \cite{Testa2022}. 

Nella progettazione di sistemi per il controllo di sistemi aggregati\footnote{Sistemi caratterizzati da un insieme di dispositivi che collaborano tra di loro per raggiungere un obiettivo comune.} si sottolinea la necessità di meccanismi che rendano possibile ed intuitivo il riutilizzo e la capacità di composizione dei componenti così da poter costruire API\footnote{Application Programming Interface} a più strati.

Ci sono diversi esempi di sistemi aggregati che necessitano di un controllo distribuito e coordinato, un esempio è il controllo di droni in formazione. In questo caso, ogni drone deve essere in grado di comunicare con i propri vicini per mantenere la formazione, evitare collisioni e raggiungere l'obiettivo comune\cref{fig:drones}. Un altro esempio è il controllo di un gruppo di robot che devono esplorare un ambiente sconosciuto con lo scopo di raccogliere informazioni.

\begin{figure}
    \centering
    \includegraphics[width=.7\linewidth]{figures/drones.jpg}
    \caption{Droni in formazione in ambiente notturno}
    \label{fig:drones}
\end{figure}

Per andare in contro a queste necessità nasce il paradigma dell'\ac{AP} che da la nascita al concetto di \textit{intelligenza collettiva}.

\subsection{Stato dell'arte}

Nei capitoli precedenti si è esaminata l'evoluzione dal paradigma \ac{OOP} a quello \ac{FP}, la quale, ha permesso di gestire in modo più pratico progetti più complessi e semplificandone la manutenibilità. Una ulteriore, più specifica, evoluzione è quella portata dal paradigma dell'\ac{AP}. Quest'ultimo mira a rendere la progettazione, manutenzione e testing nell'ambito del controllo di dispositivi hardware di larga-scala (anche conosciuti come \textbf{collective adaptive systems (CAS)} \cite{Casadei2021}).

L'\ac{AC} si basa sulla mappatura di un mondo cyber-fisico in un diverso modello logico. Da un punto di vista strutturale possiamo vedere un sistema aggregato come una rete di dispositivi capaci di computare ed equipaggiati con (o sui quali è possibile equipaggiare) sensori ed attuatori, che corrispondono ai nodi. I nodi sono connessi tra loro secondo una logica di vicinato, che può essere definita in base alla distanza fisica o alla comunicazione. Da un punto di vista comportamentale, invece, ogni nodo interpreta il programma aggregato solo in relazione al proprio contesto locale. Da un punto di vista delle interazioni, i nodi estraggono informazione dal proprio vicinato e propagano le proprie nello stesso contesto. Queste interazioni son ciò che permettono al contesto locale e globale di influenzarsi reciprocamente.

La tecnica dell'\ac{AP} si basa su 3 principi fondamentali per la costruzione di sistemi robusti e resilienti:

\begin{itemize}
    \item I dettagli implementativi dei sistemi hardware che si vuole andare a manipolare devono essere nascosti così da permettere ai programmatori di concentrarsi solo sulla logica di alto livello del sistema, in alcuni casi è possibile che questa astrazione delle specifiche di basso livello sia tale da poter essere pensato come uno spazio continuo, invece di un insieme di dispositivi separati. Per esempio, invece di immaginarci una stanza piena di sensori, la trattiamo come una area unificata definita da un flusso continuo di dati.
    \item Il programma manipola le strutture dati della rete di dispositivi sia in funzione della loro estensione spaziale che di quella temporale. Approccio particolare utile in sistemi in cui l'informazione cambia in base al luogo.
    \item Ogni dispositivo della rete esegue le operazioni necessarie in autonomia, coordinandosi con i dispositivi vicini attraverso meccanismi robusti e resilienti. In questo modo il sistema rimane fluido ed efficiente anche in situazioni anomale, ad esempio causate dal guasto di un qualche dispositivo.
\end{itemize}

L'approccio \ac{AP} nella progettazione di sistemi è profondamente diverso classico approccio ``dispositivo centrico''.
Nel secondo caso, ogni dispositivo della rete ha il compito di compiere tutte le operazioni richieste per il raggiungimento della soluzione e simultaneamente comunicare con gli altri dispositivi della rete. Questo approccio, seppur semplice, è poco scalabile e difficile da mantenere al crescere della complessità del sistema \cite{Pianini2017}. 
Il nuovo paradigma, invece, prevede la scomposizione in componenti del programma assegnato ad ogni dispositivo, ogni componente esegue un compito specifico e comunica principalmente solo con i componenti dello stesso tipo presenti nel suo intorno per eseguire un servizio ed eventualmente con un altro componente presente nello stesso dispositivo al fine di realizzare una nuova soluzione inerente ad un'altro servizio. Le componenti sono una astrazioni dei \textit{campi di calcolo}.

Il paradigma \ac{AP}, il quale ha permesso la creazione di framework come ScaFi, Protelis e MacroSwarm, si basa sul concetto dei sopracitati \textit{campi di calcolo}. Per \textit{campo di calcolo} o \textit{computationals field} si intende la mappatura degli elementi del dominio in cui si opera in un insieme di valori.
I campi di calcolo vengono utilizzati per standardizzare le interazioni tra i dispositivi, permettendo di analizzare e progettare sistemi distribuiti in modo più semplice e intuitivo. L'idea di campo prende ispirazione dai campi fisici, ad esempio quello magnetico. Ogni dispositivo della rete è considerato come un punto nello spazio ed il campo rappresenta un dato valore assegnato ad ognuno di questi punti. L'insieme di tutti i valori, che chiameremo \textit{campi} o \textit{fields} rappresentano lo stato di un sistema in un dato istante \cite{Audrito2019}.

Questo approccio è generalmente utilizzato per un controllo prolungato dei dispositivi della rete sulla quale si vogliono eseguire task che necessitano di eseguire un gran numero di rilevazioni (ad esempio utilizzando sensori), computazioni ed attuazioni.

Ogni dispositivo del proprio sistema aggregato esegue una computazione in modo asincrono attraverso i \textbf{sense-compute-(inter)act rounds}\label{sec:sense-compute-interact} \cite{Macroswarm}, ogni round è composto da tre fasi concettuali:

\begin{enumerate}
    \item \textbf{Aggiornamento del contesto (sense)}: ogni nodo memorizza il suo stato precedente, i dati ambientali restituiti da eventuali sensori e le più recenti informazioni ricevute dai nodi vicini.
    \item \textbf{Esecuzione del Programma Aggregato (compute)}: il campo di ogni nodo viene computato in base al contesto locale e produce un valore di output detto \textit{export} da condividere con il proprio vicinato ed un output utile per l'attuazione.
    \item \textbf{Azione (inter-act)}: in questa fase il nodo effettua le seguenti azioni:
    \begin{enumerate}
        \item \textbf{Condivisione}: il nodo condivide il proprio \textit{export} verso i nodi del suo vicinato in formato broadcast
        \item \textbf{Controllo attuatori}: l'output del nodo viene 
        utilizzato per l'esecuzione di uno o più attuatori nel proprio ambiente
    \end{enumerate}
\end{enumerate}


Posizionandoci in un livello più implementativo troviamo i seguenti costrutti per la manipolazione dei campi \cite{Pianini2017}: 
% //TODO: citare il paper ``Aggregate Programming for the Internet of Things'' per i seguenti costrutti

\begin{itemize}
    \item \textbf{Functions}: funzioni $$ b(e_1,\dots,e_n) $$ applicate agli argomenti $e_1,\dots,e_n$. Possono essere sia funzioni matematiche, logiche o algoritmiche ma possono anche rappresentare sensori o attuatori.
    \item \textbf{Dynamics}: $$ rep(x \leftarrow v){s_1;\dots;s_n} $$ rappresenta un una variabile di stato locale $x$, inizialmente inizializzata con il valore $v$ e che può essere modificata dalle istruzioni $s_1,\dots,s_n$. In questo modo si definisce un campo dinamico.
    \item \textbf{Interaction}: $$ nbr(s) $$ rappresenta il vicinato di un dispositivo, ovvero l'insieme dei dispositivi con cui è possibile interagire.
    \item \textbf{Restrictions}: $$
        \begin{array}{l}
        \text{if } e \\
        \qquad s_1; \quad \dots \quad s_n; \\
        \text{else} \\
        \qquad s_1'; \quad \dots \quad s_m';
        \end{array}
    $$
    permette di andare a definire sotto spazio del campo principiale in base ad una condizione $e$ sul quale poi andare ad eseguire certe istruzioni invece di altre. È importante che le istruzioni riferite ad un certo sotto spazio non abbiano effetti su altri sotto spazi.
\end{itemize}

\begin{quote}
    \centering
    Come viene eseguito un modello di \ac{AP}?
\end{quote}

Questo paradigma, proprio come quelli precedenti, non è privo di difetti. 
Implementazioni di questo tipo sono difficili da integrare in sistemi programmati in modo più tradizionale, inoltre, dal punto di vista della programmazione sono mancanti i meccanismi per la gestione della concorrenza e della computazione dinamica dei campi. Il framework ScaFi, che vedremo nel prossimo capitolo, cerca di risolvere questi problemi.

% //TODO: capitolo incompleto

\section{ScaFi}

ScaFi è un toolkit open-source scritto in linguaggio Scala per l'\ac{AC} per la progettazione ad alto livello di sistemi aggregati.
Il termine ScaFi deriva dalla unione di Scala e Fields. Scala è un linguaggio java-like moderno e flessibile progettato per unificare il paradigma \ac{OOP} e quello \ac{FP}. È stato progettato per essere coinciso e facilmente leggibile, inoltre si basa sulla Java Virtual Machine, la quale permette l'utilizzo delle librerie Java. L'utilizzo della JVM e la flessibilità del linguaggio sono state le caratteristiche chiave per il raggiungimento della popolarità di questo linguaggio. Il termine Field invece deriva dai \textit{field calculus} (campi di calcolo) di cui abbiamo parlato nei capitoli precedenti.

L'Architettura di ScaFi \cite{Casadei2022} è riassumibile nella immagine \cref{fig:scafi-arc}.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/scafi-arc.jpg}
    \caption{Architettura del framework ScaFi}
    \label{fig:scafi-arc}
\end{figure}

Ispezionando la figura, troviamo:

\begin{itemize}
    \item \textbf{scafi-commons}: fornisce le entità di base, ad esempio astrazioni temporali e spaziali
    \item \textbf{scafi-core}: rappresenta il core del framework fornendo il DSL\footnote{Domain Specific Language: linguaggio di programmazione progettato specificamente per risolvere problemi o esprimere concetti di un dominio ristretto. Il DSL di ScaFi (libreria di programmazione) è quindi un linguaggio specifico per creare e valutare programmi di tipo aggregato, utilizzando una sintassi e una semantica pensate appositamente per questo tipo di calcoli e simulazioni.} per la progettazione di sistemi aggregati; con il supporto di librerie standard.
    \item \textbf{scafi-stdlib-ext}: librerie extra
    \item \textbf{scafi-simulator}: fornisce un supporto per la simulazione dei sistemi di \ac{AP} sviluppati
    \item \textbf{scafi-simulator-GUI}: fornisce un'interfaccia grafica per la simulazione
    \item \textbf{spala}: (``spatial scala'') si tratta di un \textit{middleware} che permette di eseguire programmi \ac{AC} basati sugli attori ed è indipendente dal DSL di ScaFi
    \item \textbf{scafi-distributed}: layer integrativo per l'utilizzo di \textbf{spala} in ScaFi
\end{itemize}

\begin{quote}
    \centering
    Perché usare Scala?
\end{quote}

Il motivo per cui Scala è un linguaggio particolarmente adatto per la programmazione di sistemi di \ac{AC} è dovuto proprio alla sua flessibilità, essa permette di lavorare sui campi di calcolo, che necessitano di essere supportati dalle seguenti proprietà, in modo molto naturale:

\begin{itemize}
    \item una sintassi coincisa per definire funzioni sui campi, le quali in Scala sono le espressioni standard
    \item meccanismi di controllo sul \textit{quando} e \textit{come} le espressioni vengono valutate
    \item capacità di calcolare lo stato di un campo basandosi sulle informazioni più recenti dei nodi presenti nel suo intorno
\end{itemize}

In Scala ogni valore è un oggetto ed i comportamenti vengono definiti attraverso i metodi. Per implementare un campo di calcolo in Scala andremo a definire gli operato dei campi attraverso la definizione di metodi che verranno interpretati dagli oggetti sui quali sono stati chiamati. Gli oggetti, in questo modo, possono essere visti come macchine virtuali in locale per l'esecuzione degli operatori di campo.

Di seguito l'interfaccia fondamentale per la definizione di un campo di calcolo in Scala (\cref{lst:constructs-scala}):

\lstinputlisting[float=tb,language=Scala,label={lst:constructs-scala},caption={Interfaccia per la definizione di un campo di calcolo in Scala}]{listings/Constructs.scala}

Gli elementi principali di questa interfaccia sono \cite{Casadei2022}:
\begin{itemize}
    \item \verb|rep(init)(f)| cattura l'evoluzione di stato di un valore inizializzato ad \verb|init| e aggiornato ad ogni round con la funzione \verb|f|
    \item \verb|nbr(expr)|: rileva le comunicazioni relative al valore computato dalla espressione \verb|expr| dei nodi vicini
    \item \verb|foldhood(init)(acc)(expr)|: si occupa, partendo da un valore iniziale \verb|init|, di accumulare i valori computati dai nodi vicini attraverso la funzione di accumulazione \verb|acc| e settare i valori computati dalla espressione \verb|expr| verso i propri vicini
    \item \verb|branch(cond)(th)(el)|: cattura una partizione (spazio-temporale) del dominio in base alla condizione \verb|cond|, se questa è rispettata esegue l'espressione \verb|th| altrimenti \verb|el|
    \item \verb|mid|: provvede ad identificare un certo nodo
    \item \verb|sense(sensorName)|: permette di accedere (ad alto livello) al sensore locale \verb|sensorName|
    \item \verb|nbrvar(sensorName)|: permette di accedere (ad alto livello) ai sensori dei nodi vicini, simile ad \verb|nbr| ma valido per sensori forniti dalla piattaforma, questi sensori forniscono un valore per ciascun vicino
\end{itemize}

In ScaFi, i campi non sono reificati esplicitamente ma esistono solo a livello semantico, questo significa che un'espressione Scala non viene gestita come un'espressione di campo finché non viene passata all'interprete ScaFi.
% //TODO: citare la tesi PhD di Casadei

ScaFi fornisce alcuni operatori, detti anche \textit{blocchi}, di alto livello già implementati tipici dei sistemi aggregati \cite{Casadei2022}:

\begin{itemize}
    \item \textbf{Sparse choice (definizione di un leader)}: Blocco 
    \begin{center}
        \verb|S(grain: Double):Boolean|
    \end{center}
    produce un campo booleano auto organizzato che definisce a \verb|true| un insieme sparso di dispositivi distanziati tra di loro di almeno \verb|grain|
    \item \textbf{Gradient-cast (propagazione distribuita)}: Blocco 
    \begin{center}
        \verb|G[T](source: Boolean, value: T, acc: T=>T): T|
    \end{center}
    utilizzato per propagare un valore \verb|value| da una sorgente \verb|source| a tutti i nodi della rete, in ordine di distanza crescente, seguendo un gradiente che modifica i valori di ogni nodo secondo una funzione di accumulo \verb|acc|
    \item \textbf{Collect-cast (collezione distribuita)}: Blocco 
    \begin{center}
        \verb|C[T](sink: Boolean, value: T, acc(T,T)=>T): T| 
    \end{center}
    utilizzata per riassumere le informazioni distribuite in un unico dispositivo \verb|sink|, i valori \verb|values| prodotti dai dispositivi vengono ``raccolti'' dal gradiente che si muove in direzione di \verb|sink| e vengono accumulati secondo la funzione di accumulo \verb|acc|
\end{itemize}

\section{Macroswarm}

Macroswarm è un framework per la programmazione di sistemi di robotica distribuita basato su ScaFi e che estende lo stesso ScaFi. Macroswarm nasce con l'avanzare delle tecnologie ed il crescente interesse verso il controllo di flotte di dispositivi come droni, robot, veicoli o folle di persone definite da dispositivi portatili/indossabili in modo.
Si è voluto, quindi, creare un framework che permettesse di programmare sistemi distribuiti di robot in modo semplice ed intuitivo secondo degli \textit{swarm behavior}\footnote{Comportamenti di sciame/flotta}, permettendo di concentrarsi solo sulla logica di alto livello del sistema. Questo framework è stato scelto per il progetto in esamina.
Il paradigma \ac{AP} e di conseguenza ScaFi sono state scelte naturali per la progettazione di tale framework (\cref{fig:macro-swarm-arc}) \cite{Macroswarm}.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/macroSwarm-arc.pdf}
    \caption{Architettura di Macroswarm}
    \label{fig:macro-swarm-arc}
\end{figure}

Fondamentalmente, Macroswarm è un programma ScaFi il quale esegue un certo programma aggregato su una certa piattaforma. L'idea è quella di creare una rappresentazione astratta di una flotta di dispositivi attraverso campi di calcolo, tipicamente vettori.
All'intero del Framework troviamo le API per progettazione dei sistemi aggregati su sistemi fisici (i rettangoli bianchi in \cref{fig:macro-swarm-int} rappresentano i moduli principali).

\begin{figure}
    \centering
    \includegraphics[width=.99\linewidth]{figures/macroSwarm-modeles.pdf}
    \caption{Struttura di Macroswarm e moduli interni}
    \label{fig:macro-swarm-int}
\end{figure}

È rilevante notare che in Macroswarm la computazione della attuazione da eseguire su un certo dispositivo e la reale attuazione nel mondo reale sono disaccoppiate. Il motivo di questa scelta è dovuto al fatto che ad ogni round\cref{sec:sense-compute-interact} il programma aggregato può variare un qualche parametro per completare il task. È, comunque, possibile scegliere quale modalità di computazione-attuazione scegliere poiché, in base al contesto, una può essere più adatta dell'altra \cite{Macroswarm}. Le modalità sono:

\begin{itemize}
    \item \textbf{round-based}(\cref{fig:round-based}): è possibile eseguire l'attuazione al termine del prossimo round 
    \item \textbf{long-standing}(\cref{fig:long-standong}): l'attuazione che si vuole eseguire è valida finché non viene revisionata o ritirata
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=.6\linewidth]{figures/round-based.pdf}
    \caption{Modalità Round Based}
    \label{fig:round-based}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=.99\linewidth]{figures/long-standing.pdf}
    \caption{Modalità Long Standing}
    \label{fig:long-standong}
\end{figure}

Questo modello di attuazione è modellato come una funzione pura\cref{sec:fp} quindi priva di effetti collaterali. Se ci si trova in un contesto in cui l'esecuzione dell'attuazione richiede un certo tempo allora il progettista del sistema aggregato può andare a modellare il sistema in modo tale da tenere in considerazione questo aspetto.

Come è possibile vedere in \cref{fig:macro-swarm-int} \cite{Macroswarm} il framework è composto da diversi moduli che a loro volta contengono diversi blocchi, ognuno con un compito specifico, solo alcuni di questi blocchi sono sono stati utilizzati per la realizzazione del progetto e saranno descritti nei prossimi paragrafi.

\paragraph{Movements blocks} 
Questi blocchi si occupano di controllare i movimenti di ogni agente (dispositivo) della flotta. Il Movimento più semplice è descritto da un vettore \verb|Vector(x,y,z)| che rappresenta la direzione e la velocità del movimento, ad esempio 

\begin{lstlisting}[language=Scala, label={lst:vector-example}]
    Vector(3.6, 0, 0)
\end{lstlisting}

rappresenta un movimento di $3.6 \frac{m}{s}$ lungo l'asse $x$. Una volta definito il blocco di movimento per un certo agente, i valori $x,y,z$ devono essere accuratamente mappati sui motori del dispositivo per ottenere il movimento desiderato. Carattere di fondamentale importanza quando si lavora su un sistema eterogeneo e quindi formato da dispositivi differenti equipaggiati da motori differenti.

Un'altro blocco ``semplice'' è \verb|brownian| che genera un vettore di movimento casuale ad ogni round, è possibile definire uno scalare (\verb|scale|) che rappresenta la velocità massima del movimento casuale.

Sono disponibili anche blocchi più complessi (\cref{lst:movement-module}), alcuni di questi simulati in \cref{fig:movement-simulations}:
\begin{itemize}
    \item \verb|goTo|: permette di definire un target (posizione assoluta) alla quale un agente deve arrivare
    \item \verb|explore|: definito uno spazio rettangolare con i valori \verb|minBound| e \verb|maxBound|, il blocco produce vettori da assegnare all'agente per esplorare l'intero spazio
    \item \verb|maintainTrajectory|: permette di mantenere un certo vettore di movimento per un certo periodo di tempo
    \item \verb|maintainUntil|: permette di mantenere un certo vettore di movimento fino a quando non viene raggiunta una certa condizione
    \item \verb|obstacleAvoidance|: genera vettori di movimento da assegnare agli agenti per evitare ostacoli
\end{itemize}

In figura \cref{fig:movement-simulations} \cite{Macroswarm} sono state simulate le funzioni \verb|goTo|, \verb|explore| \\ e \verb|obstacleAvoidance| su Alchemist, un simulatore di sistemi aggregati.

\begin{figure}
    \centering
    \includegraphics[width=.9\linewidth]{figures/movement-simulations.pdf}
    \caption{Simulazioni dei blocchi di movimento eseguita su Alchemist.}
    \label{fig:movement-simulations}
\end{figure}

\begin{lstlisting}[language=Scala, label={lst:movement-module} caption={Funzioni del modulo di movimento}]
    // movimento casuale
    def brownian(scale: Double): Vector
    
    // posizioni assolute
    def goTo(target: Point3D): Vector
    def explore(minBound: Point3D, maxBound: Point3D): Vector

    // condizioni temporali
    def maintainTrajectory(trajectory: => Vector)(time: FiniteDuration):Vector

    // condizioni booleane
    def maintainUntil(direction: Vector)(condition: Boolean): Vector

    // elusione ostacoli
    def obstacleAvoidance(obstacles: List[Vector]): Vector
\end{lstlisting}

Questi blocchi possono essere assemblati per costruirne di nuovi più complessi, ad esempio, per creare un comportamento ``muovi fino a destinazione evitando gli ostacoli'':

\begin{lstlisting}[language=Scala, label={lst:complex-movement} caption={Comportamento complesso}]
    def moveToTargetAvoidingObstacles(target: Point3D, obstacles: List[Vector]): Vector = {
        val targetMovement = goTo(target)
        val obstacleAvoidanceMovement = obstacleAvoidance(obstacles)
        (targetMovement + obstacleAvoidanceMovement).normalize
    }
\end{lstlisting}

La composizione di questi blocchi permette di creare comportamenti complessi in modo semplice e intuitivo andando a sommare comportamenti più semplici. È importante andare a \textit{normalizzare} il risultato del comportamento complesso per produrre un singolo vettore nel caso in cui il movimento sia composto da più vettori.

\paragraph{Leader-based blocks} Per gestire un insieme di agenti in modo coordinato per raggiungere un obiettivo si è valutato che ci fosse la necessità di avere un nodo leader che si occupasse di coordinare gli altri nodi. Il leader può essere scelto secondo un certo criterio (ad esempio per le sue caratteristiche speciali oppure per la sua posizione all'interno del gruppo) oppure casualmente ma è anche possibile andare a creare un leader \textit{virtuale}, che quindi non è realmente presente nel ambiente. Allo stato attuale sono presenti solo due blocchi ritenuti essenziali:
\begin{itemize}
    \item \verb|alignWithLeader|: permette di allineare la velocita degli agenti con quella del leader
    \item \verb|sinkAt|: permette di far convergere gli agenti verso il leader
\end{itemize} 

Nel caso si necessiti di avere un comportamento più complesso che porti alla nascita di sotto-team si possono utilizzare i blocchi presenti in \textbf{Team formation blocks} che non approfondiremo in questo contesto.

\paragraph{Pattern formation blocks}
Per creare comportamenti coordinati per un team al fine di raggiungere un task si possono usare i blocchi presenti in \textbf{Leader-based blocks} e \textbf{Team formation blocks}, nel caso invece si è interessati soltanto alla forma geometrica che il team deve assumere si possono usare i blocchi presenti in \textbf{Pattern formation blocks}. La seconda tipologia di blocchi è una derivazione della prima poiché necessita della identificazione di un leader, il leader si occupa di collezionare le distanze dei propri ``sottoposti'' per poi assegnare loro una certa direzione per raggiungere la formazione desiderata. Il leader utilizza il Gradient-cast ed i Collect-cast per raccogliere le informazioni e utilizza, nuovamente, Gradient-cast per assegnare le direzioni.

Allo stato attuale del framework è possibile costruire in modo semplice le seguenti figure geometriche:
\begin{itemize}
    \item formazione a ``V'', come quella dei volatili
    \item linea
    \item cerchio
\end{itemize}

Tutte e tre le formazioni \cref{fig:formation-simulations} \cite{Macroswarm} si possono muovere nello spazio e necessitano di un leader che può anche variare velocità, in quel caso i nodi vicini si adatteranno alla velocità del leader. Questo tipo di formazioni sono capaci di ricostruirsi anche nel caso cambi il numero di nodi oppure un fenomeno esterno vada a disturbarne la struttura.

\begin{figure}
    \centering
    \includegraphics[width=.9\linewidth]{figures/formation-simulations.pdf}
    \caption{Simulazioni delle formazioni eseguite su Alchemist, in ordine: linea, formazione a V, cerchio.}
    \label{fig:formation-simulations}
\end{figure}

\section{Thymio e tdmclient}

\begin{quote}
    \raggedright
    ``Thymio è un robot educativo open-source progettato da ricercatori dell'EPFL (Politecnico federale di Losanna), in collaborazione con l'ECAL (Università d'arte e design di Losanna), e prodotto da Mobsya, un'associazione no-profit la cui missione è quella di offrire percorsi STEAM completi e coinvolgenti a studenti di tutte le età.''
    \begin{flushright}
        \textit{-- \href{https://www.thymio.org/}{Mobsya}}
    \end{flushright}
\end{quote}

\begin{figure}
    \centering
    \includegraphics[width=.7\linewidth]{figures/thymio.png}
    \caption{Robot Thymio}
    \label{fig:thymio-robot}
\end{figure}

Thymio \cite{mobsyaThymioDevice} è un robot programmabile con un'ampia varietà di sensori e attuatori, tra cui:
\begin{itemize}
    \item 9 sensori a infrarossi (portata circa 10 cm)
    \item 5 pulsanti a sfioramento (tecnologia capacitiva)
    \item 1 accelerometro a tre assi
    \item 1 termometro
    \item 1 microfono
    \item 1 ricevitore a infrarossi per il telecomando
    \item 39 LED controllabili
    \item 2 motori DC collegati alle ruote
    \item 1 altoparlante
\end{itemize}

Il deploy del codice sul robot Thymio avviene tramite un radio dongle USB.
\paragraph{Thymio Network}: La connessione wireless dei robot è basata sul protocollo \href{https://en.wikipedia.org/wiki/IEEE_802.15.4}{802.15.4} in banda con frequenza 2.4 GHz \cite{wikidotSettingWireless}. Questo protocollo permette di gestire una rete con molti nodi a discapito del rispetto delle seguenti condizioni:

\begin{itemize}
    \item tutti i nodi devono trovarsi tutti nello stesso canale radio (sono disponibili 3 reti: [0, 1, 2])
    \item tutti i dispositivi devono avere lo stesso Identificativo di rete (PAN ID)
    \item tutti devono avere un nodo Identificativo univo (nodeID)
\end{itemize}

Questo protocollo è stato scelto per la sua bassa potenza e la sua affidabilità. Il protocollo è stato implementato in modo da permettere la comunicazione tra i robot e con il computer tramite il dongle USB.

Il dispositivo è stato scelto per essere implementato nella demo per la notte dei ricercatori in quanto è un robot molto versatile e adatto a molteplici applicazioni. Inoltre, il robot è molto diffuso nelle scuole e nei laboratori di robotica educativa, quindi è un'ottima scelta per mostrare il potenziale di ScaFi in un contesto educativo.

Questo piccolo robot nasce per essere programmato con linguaggi a blocchi come VPL, VPL3, Scratch, Blocky e non come Aseba, Python e Ros, tutti accessibili dalla suite dedicata \textit{``Thymio Suite''} \cite{mobsyaThymioDevice}.

Noi ci concentreremo sul uso di Python. 

% //TODO: da scrivere meglio
Python a differenza di altri linguaggi (ad esempio C/C++) è interpretato e non compilato. I linguaggi compilati prevedono la conversione del programma scritto in un linguaggio ad alto livello in linguaggio macchina per poi farlo eseguire dal processore, occorre quindi compilare il sorgente ad ogni nuova modifica per poi re-eseguirlo. Python, invece, è un linguaggio interpretato, il codice sorgente viene eseguito direttamente dal programma interprete, il quale esegue ogni comando riga per riga \cite{robotadvanceUsingEducational}.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/interpreter-compiler.pdf}
    \caption{Interprete vs Compilatore}
    \label{fig:interpreter-vs-compiler}
\end{figure}

Nel caso del robot Thymio, non è presente un interprete nel suo microcontrollore. È presente, invece, una Aseba Virtual Machine che permette di eseguire programmi scritti in linguaggio Aseba. 

Aseba è un linguaggio di programmazione ad alto livello basato su architettura ad eventi, il che significa che gli eventi sono eseguiti in modo asincrono. Gli eventi sono identificati da un Identificativo ed opzionalmente da un \textit{payload} (dati aggiuntivi). 
Gli eventi possono essere di due tipi:
\begin{itemize}
    \item \textbf{global events}: eventi generati dai nodi e condivisi con la rete
    \item \textbf{local events}: eventi generati da un nodo e non condivisi con la rete (ad esempio un evento generato da un sensore dello stesso nodo)
\end{itemize}

Un esempio di codice Aseba è il seguente \cref{lst:aseba-code}.
% Non è disponibile Aseba quindi useremo Python
\begin{lstlisting}[language=Python, label={lst:aseba-code}, caption={Esempio di codice Aseba con eventi}]
    var state

    callsub init  # Inizializza il programma

    sub init
        state = 0
        call leds.bottom.left(0,0,32)
        call leds.bottom.right(0,32,0)
        call leds.top(32,0,0)

    # Re-inizia quando il pulsante centrale viene premuto
    onevent button.center
        callsub init
\end{lstlisting}

Il \textbf{Thymio Device Manager} è una delle feature della Thymio Suite, si occupa di gestire la rete dei Thymio. Inoltre ha il compito di tradurre il sorgente, scritto dall'utente, da linguaggio Aseba ad Aseba bytecode per poi eseguire il \textit{deploy} sul robot. Per l'utilizzo di Python, invece, è necessario l'utilizzo del modulo \textbf{tdmclient} che si occupa di far comunicare Python con il \ac{TDM} \cref{fig:tdmclient} \cite{pypiTdmclient}. È necessario che la Thymio Suite sia in esecuzione per poter utilizzare il modulo \textbf{tdmclient}, il quale, a sua volta, necessita dell'utilizzo di \textbf{Python 3} come interprete.

Questo modulo permette di:
\begin{itemize}
    \item accedere alle variabili, sensori, attuatori del robot
    \item convertire uno script Python in un script Aseba (transpiler)
    \item inviare codice Aseba al \ac{TDM} che a sua volta invia il relativo bytecode al  robot Thymio 
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/TDM.pdf}
    \caption{Tdmclient workflow}
    \label{fig:tdmclient}
\end{figure}

Le possibilità offerte da questo modulo sono molteplici, ad esempio è possibile inviare comandi direttamente ad un robot Thymio da terminale:

\begin{lstlisting}[language=Bash, label={lst:command-to-thymio}, caption={Esempio di invio di comando (foo) ad un robot Thymio}]
    python3 -m tdmclient sendevent --event foo --data 123
\end{lstlisting}

In \cref{lst:command-to-thymio} si assume che il robot accetti un evento di nome \textit{foo} con un payload di tipo intero e che il robot sia in ascolto di eventi (\textit{unlocked}). Per metter in ascolto un robot di un certo evento è necessario andare ad inserire una vista su quel determinato robot dalla Thymio Suite.

\begin{lstlisting}[language=Python, label={lst:thymio-catch-event}, caption={Esempio di programma interno a Thymio per la ricezione di eventi (foo)}]
    var x

    onevent foo
        x = event.args[0]
\end{lstlisting}

Il modulo permette di eseguire il transpile (conversione) di un programma Python in Aseba. Per farlo è necessario utilizzare il comando \textit{transpile} del modulo \textbf{tdmclient}:

\begin{lstlisting}[language=Bash, label={lst:transpile-python-to-aseba}, caption={Esempio di transpile di un programma Python (print.py) in Aseba}]
    python3 -m tdmclient transpile examples/print.py
\end{lstlisting}

Utilizzando il modulo aggiuntivo \verb|ClientAsync| è possibile modificare le variabili dei robot Thymio attraverso chiamate asincrone in uno script \textbf{Python}.
Si andrà ad esaminare ulteriormente questa feature di \textbf{tdmclient} nel capitolo \cref{chap:design} e \cref{chap:implementazione} poiché è ciò che si è utilizzato per la progettazione del nostro sistema.

\section{Aruco Tag}

Gli Aruco marker sono tag quadrati che possono essere rilevati da una camera. Ogni tag è una matrice $4 \times 4$ ed ha un codice (intero) univoco associato che può essere rilevato da un algoritmo di visione artificiale\cref{fig:aruco-markers} \cite{opencvOpenCVDetection}. È rilevante notare che la matrice di ogni Aruco marker corrisponde ad uno stesso codice per ogni sua versione trasposta. 
Questi tag sono molto utili per la localizzazione e la navigazione di robot autonomi. Sarà questo strumento che verrà utilizzato per la demo della notte dei ricercatori per la localizzazione e calcolo della direzione dei robot Thymio.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/aruco-markers.png}
    \caption{Aruco markers identificati da un algoritmo di visione artificiale}
    \label{fig:aruco-markers}
\end{figure}

Questo strumento è già presente nel sistema in questione.

%----------------------------------------------------------------------------------------
\chapter{Analisi}
\label{chap:analisi}
%----------------------------------------------------------------------------------------

\section{Obiettivi}
Il progetto \href{https://github.com/cric96/researcher-night-demo.git}{``researcher-night-demo''} è nato per dimostrare, attraverso simulazioni in ambiente reale, le potenzialità di ScaFi. L'obiettivo di questo progetto è dimostrare l'eterogeneità di questo tipo di sistemi andando ad estendere ai robot già implementati il supporto per un nuovo modello di robot, il Thymio, e andando a gestire i vincoli di compatibilità del sistema Thymio.

Inizialmente, la demo, presentava soltanto la possibilità di utilizzare i robot Wave \cref{fig:wave-robot}. I Wave sono robot equipaggiati da 4 ruote motrici (4WD), scocca d'acciaio ed un modulo ESP32 (microcontrollore programmabile) già implementato di software (open-source) con il quale si può comunicare tramite protocollo WiFi o Bluetooth.
Il progetto è stato esteso per includere il modello di robot Thymio \cref{fig:thymio-robot}. 

\begin{figure}
    \centering
    \includegraphics[width=.3\linewidth]{figures/wave-robot.jpg}
    \caption{Robot Wave}
    \label{fig:wave-robot}
\end{figure}

\section{Requisiti}

Requisiti funzionali:
\begin{itemize}
    \item Il sistema è progettato per l'utilizzo di grandi quantità di dispositivi eterogenei quindi si ritiene necessario che vengano caricati attraverso file di configurazione invece che essere definiti direttamente nel codice. Questo permette di avere un sistema più flessibile e facilmente estendibile.
    \item Integrare robot Thymio nel sistema già esistente.
\end{itemize}

Requisiti non funzionali:
\begin{itemize}
    \item Refactoring del codice Java per il tracciamento dei robot.
    \item Velocità nelle comunicazioni con i nuovi robot integrati.
\end{itemize}

\section{Dominio}

Il progetto è stato sviluppato in linguaggio Scala ed è formato da tre componenti fisiche:
\begin{itemize}
    \item webcam per il tracciamento dei ArucoTag posizionati sopra ai robot
    \item macchina che esegue il sistema aggregato e che comunica con i robot, solitamente un computer
    \item robot (uno o più)
\end{itemize}

La struttura del progetto si basa sul principio di Macroswarm, posizionandosi ad un livello di astrazione abbastanza alto da nascondere i dettagli implementativi dei dispositivi che si vuole andare a controllare. Di seguito un breve sommario delle componenti principali del progetto:

\paragraph{Tracciamento robot}.
Per il tracciamento dei robot attraverso la webcam è stato sviluppato un applicativo Java di visione artificiale che rileva i tag Aruco e ne calcola la posizione e l'orientamento.

\paragraph{Core}. 
Il core del sistema è basato su ScaFi.
Per costruire i sistemi aggregati si utilizza la classe \verb|AggregateIncarnation| \cref{lst:agg-inc} che serve a poter definire i diversi programmi aggregati.

\begin{lstlisting}[language=Scala, label={lst:agg-inc}, caption={Classe AggregateIncarnation}]
    import it.unibo.scafi.incarnations.BasicAbstractIncarnation

    object AggregateIncarnation extends BasicAbstractIncarnation with BuildingBlocks
\end{lstlisting}

L'interfaccia \verb|Environment|\cref{lst:enviroment} rappresenta l'astrazione del mondo, essa rappresenta lo stato del mondo in un dato istante e va definita in base al contesto.

\begin{lstlisting}[language=Scala, label={lst:enviroment}, caption={Interfaccia Enviroment}]
    trait Environment[ID, Position, Info]:
        def nodes: Set[ID] // insieme di nodi definiti dagli identificatori ID
        def position(id: ID): Position // posizione di un certo nodo
        def sensing(id: ID): Info // le informazioni che un certo nodo espone
        def neighbors(id: ID): Set[ID] // vicinato di un certo nodo
\end{lstlisting}

La classe \verb|AggregateOrchestrator| è la componente principale del sistema poiché si occupa di leggere lo stato del mondo e ritornare l'attuazione da eseguire (export) per ogni agente.

\paragraph{Demo}
In demo si trova la reale implementazione del sistema aggregato che produce le attuazioni nel mondo reale a partire dalla definizione del ambiente in cui si lavora\cref{lst:demo-env}.

\begin{lstlisting}[language=Scala, label={lst:demo-env}, caption={Definizione dell'ambiente}]
    import it.unibo.core.DistanceEstimator.distance
    import it.unibo.core.Environment
    import it.unibo.demo.{ID, Info}
    import it.unibo.utils.Position.{Position, *, given}

    class DemoEnvironment(data: Map[ID, (Position, Info)], neighboursRadius: Double)
        extends Environment[ID, Position, Info]:

    override def nodes: Set[ID] = data.keySet

    override def position(id: ID): (Double, Double) = data(id)._1

    override def sensing(id: ID): Info = data(id)._2

    override def neighbors(id: ID): Set[ID] =
        data.filter { case (k, v) => data(id)._1.distance(v._1) <= neighboursRadius }.keys.toSet
\end{lstlisting}

\paragraph{Mock}
Il progetto dispone anche di uno spazio per testare programmi aggregati in un ambiente simulato implementato utilizzando la libreria \verb|JavaFX|. Questo ambiente permette di vedere i nodi della rete e le connessioni tra di essi.


%----------------------------------------------------------------------------------------
\chapter{Design}
\label{chap:design}
%----------------------------------------------------------------------------------------

A seguito di un analisi delle caratteristiche dei robot Thymio e dei protocolli di comunicazione che esso mette a disposizione si è optato per l'utilizzo del modulo \textbf{tdmclient} nel contesto di un server sviluppato utilizzando il framework Flask. Questo framework è stato sviluppato per la creazione di applicazioni web e, in particolare, per la creazione di \textit{API RESTful}\footnote{Le API sono l'interfaccia che utilizzano due o più sistemi informatici per lo scambio sicuro di informazioni. REST è un'architettura software sulla quale si possono progettare le API}. Questo framework è stato scelto per la sua semplicità, la sua flessibilità, scalabilità e indipendenza dalla tecnologia utilizzata. 

Si è valutato anche l'utilizzo della libreria ScalaPy, che permette di sfruttare i moduli Python all'interno di un programma Scala, per incorporare le funzionalità di tdmclient direttamente all'interno del sistema aggregato ma data la ``non stabilità'' del progettato ScalaPy si è deciso di non impiegare questa soluzione.

\section{Architettura server Flask}

Il server sviluppato si occupa di gestire la comunicazione con due client\cref{fig:server-arc}:
\begin{itemize}
    \item il client Thymio Device Manager (TDM) che comunica con i robot Thymio
    \item il client che ospita il programma aggregato
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/server-arc.pdf}
    \caption{Architettura del server Flask}
    \label{fig:server-arc}
\end{figure}

Come è possibile vedere in figura \cref{fig:server-arc} il programma aggregato utilizza una webcam per tracciare i robot, computate le posizioni e le direzioni dei robot, queste informazioni vengono elaborate dal programma aggregato ed al fine di completare il task vengono inviati comandi per ogni Thymio al server Flask che, attraverso \textbf{tdmclient} si occupa di eseguire le attuazioni richieste. 

\section{File di configurazione}

Per utilizzare i file di configurazione all'interno del progetto Scala è stata utilizzata la libreria \textbf{uPickle}. È una libreria performante che permette un parsing veloce ed intuitivo, inoltre non ha problemi di dipendenze quindi può essere utilizzata in qualsiasi progetto Scala senza produrre conflitti \cite{uPickle}.

%----------------------------------------------------------------------------------------
\chapter{Implementazione}
\label{chap:implementazione}
%----------------------------------------------------------------------------------------

\section{Implementazione del server Flask}

Lato Server, sono di rilevanza le implementazioni per rilevare i robot Thymio nella rete \cref{lst:setup-thymios} e per ricevere, attraverso l'API \cref{lst:api} i comandi per controllarli \cref{lst:command-to-thymio}.

\lstinputlisting[language=Python,label={lst:setup-thymios},caption={Funzione di setup per rilevare i Thymio nella rete}]{listings/getTymios.py}

L'API è stata costruita sotto forma di richiesta GET con parametro un JSON contente l'identificato fisico univoco del Thymio, la potenza da erogare nel motore sinistro e destro (nel caso la potenza sia negativa il motore andrà in senso inverso) \cref{lst:api}.

\lstinputlisting[language=php,label={lst:api},caption={API per il controllo dei Thymio}]{listings/api.url}

\lstinputlisting[language=Python,label={lst:move-thymios},caption={Implementazione API per inivare un comando di movimento al Thymio}]{listings/moveThymio.py}

Lato programma aggregato, invece, troviamo l'implementazione di una classe che nasconde ogni tipo di dettaglio implementativo per il controllo dei robot, sia Wave che Thymio \cref{lst:robot-control}.

\lstinputlisting[language=Scala,label={lst:robot-control},caption={Classe per il controllo dei robot}]{listings/Robot.scala}

Per gestire l'inserimento o la rimozione di nuovi robot nel sistema in modo dinamico si è scelto di utilizzare i file di configurazione \cref{lst:thymio-config} \cref{lst:wave-config}.

\lstinputlisting[language=Python, label={lst:thymio-config},caption={File di configurazione per i robot Thymio}]{listings/thymio-config.json}

\lstinputlisting[language=Python, label={lst:wave-config},caption={File di configurazione per i robot Wave}]{listings/wave-config.json}

Questi file di configurazione vengono caricati utilizzando la libreria uPickle \cite{uPickle} \cref{lst:uPickle-read}.

\lstinputlisting[language=Scala,label={lst:uPickle-read},caption={Lettura dei file di configurazione}]{listings/upickle.scala}


\section{Esempi di Algoritmi AP applicati ai Robot Wave e Thymio nello stesso ambiente}

\paragraph{Copia rotazione del Leader}
Programma Aggregato per far ruotare i robot del sistema seguendo la direzione del leader \cref{lst:rotate-leader} \cref{fig:rotate-leader}.

\lstinputlisting[language=Scala,label={lst:rotate-leader},caption={Programma aggregato per far ruotare i robot del sistema seguendo la direzione del leader}]{listings/FollowLeaderRotating.scala}

\begin{figure}
    \centering
    \includegraphics[width=.99\linewidth]{figures/rotate-leader.pdf}
    \caption{Simulazione del programma aggregato per far ruotare i robot del sistema seguendo la direzione del leader .}
    \label{fig:rotate-leader}
\end{figure}

\paragraph{Formazione a ``linea''}
Programma aggregato che si occupa di allineare i robot del sistema al fine di creare una linea retta \cref{lst:line-shape} \cref{fig:line-shape-1} \cref{fig:line-shape-2}.

\lstinputlisting[language=Scala,label={lst:line-shape},caption={Programma aggregato allineare i robot}]{listings/LineShape.scala}

\begin{figure}
    \centering
    \includegraphics[width=.99\linewidth]{figures/line2.pdf}
    \caption{Simulazione del programma aggregato per allineare i robot.}
    \label{fig:line-shape-2}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=.99\linewidth]{figures/line1.pdf}
    \caption{Simulazione del programma aggregato per allineare i robot dalla dalla visuale del programma di tracking dei Aruco Tag (la linea rossa è  stata inserita in post produzione).}
    \label{fig:line-shape-1}
\end{figure}

\paragraph{Formazione a ``cerchio''}

Programma aggregato che si occupa di definire un leader e produrre una formazione circolare intorno ad esso \cref{lst:circle-shape}. È possibile notare dalla immagine \cref{fig:circle-formation} come il programma si comporti correttamente anche in situazioni anomale come la rimozione o l'inserimento di nuovo robot nell'ambiente.

\lstinputlisting[language=Scala,label={lst:line-shape},caption={Programma aggregato allineare i robot}]{listings/CircleShape.scala}

\begin{figure}
    \centering
    \includegraphics[width=.99\linewidth]{figures/circle.pdf}
    \caption{Simulazione del programma aggregato per produrre un cerchio intorno ad un leader.}
    \label{fig:line-shape-1}
\end{figure}

%----------------------------------------------------------------------------------------
\chapter{Conclusione}
\label{chap:conclusione}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter

\nocite{*} % Remove this as soon as you have the first citation

\bibliographystyle{alpha}
\bibliography{bibliography}

\begin{acknowledgements} % this is optional
Optional. Max 1 page.
\end{acknowledgements}

\end{document}
