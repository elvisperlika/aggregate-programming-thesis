\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}
\usepackage{float}

\school{\unibo}
\programme{Corso di Laurea in Ingegneria e Scienze Informatiche}
\title{Eterogeneità dei sistemi di Aggregate Programming: estensione del sistema ScaFi per l'uso di robot Thymio}
\author{Elvis Perlika}
\date{\today}
\subject{Objective Oriented Programming}
\supervisor{Chiar.mo Prof. Mirko Viroli}
\cosupervisor{Dott. Gianluca Aguzzi}
\session{III}
\academicyear{2023-2024}

% Definition of acronyms
\acrodef{IoT}{Internet of Thing}
\acrodef{vm}[VM]{Virtual Machine}
\acrodef{FP}{Functional Programming}
\acrodef{RT}{Referential Transparency}
\acrodef{AP}{Aggregate Programming}
\acrodef{OOP}{Objective Oriented Programming}
\acrodef{AC}{Aggregate Computing}
\acrodef{TDM}{Thymio Device Manager}

\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
Max 2000 characters, strict.
\end{abstract}

\begin{dedication} % this is optional
    Qualsiasi tecnologia sufficientemente avanzata è indistinguibile dalla magia. \\ Terza Legge di Arthur C. Clarke
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

Write your intro here.
\sidenote{Add sidenotes in this way. They are named after the author of the thesis}

You can use acronyms that your defined previously,
such as \ac{IoT}.
%
If you use acronyms twice,
they will be written in full only once
(indeed, you can mention the \ac{IoT} now without it being fully explained).
%
In some cases, you may need a plural form of the acronym.
%
For instance,
that you are discussing \acp{vm},
you may need both \ac{vm} and \acp{vm}.

\paragraph{Structure of the Thesis}

\note{At the end, describe the structure of the paper}

%----------------------------------------------------------------------------------------
\chapter{Background}
\label{chap:background}
%----------------------------------------------------------------------------------------

% I suggest referencing stuff as follows: \cref{fig:random-image} or \Cref{fig:random-image}

% \begin{figure}
%     \centering
%     \includegraphics[width=.8\linewidth]{figures/random-image.pdf}
%     \caption{Some random image}
%     \label{fig:random-image}
% \end{figure}


\section{Paradigma dell'Aggregate Programming}

\subsection{Evoluzione dei paradigmi di programmazione}

L'Objective Oriented Programming è un paradigma nel senso stretto del termine poiché rappresenta un modo di organizzare e rappresentare un mondo. 
Il paradigma in questione deve la sua potenza nella capacità di simulare entità reali ed è riassumibile con la frase \textit{Everything is an Object}. 
È rilevante parlare di OOP in quanto il paradigma di programmazione funzionale, che è alla base di ScaFi, è un'estensione di esso. 
Il potere della programmazione ad Oggetti (OOP), come detto precedentemente, risiede nella capacità di simulare un mondo e permette di farlo grazie agli "oggetti", essi sono istanze di Classi, le quali a loro volta sono strutture dati astratte che permettono ad ogni loro istanza di avere uno stato (definito dai \textit{fields}) e un comportamento (definito dai \textit{methods}).
I pilastri della programmazione ad oggetti sono l'incapsulamento, l'ereditarietà e il polimorfismo.

Il difetto della programmazione ad oggetti è che richiede un particolare impegno nel gestire il sistema da realizzare all'aumentare della sua complessità. Altri paradigmi, come la programmazione funzionale, possono essere più adatti a determinati problemi.

Nel caso della OOP abbiamo riassunto il paradigma con la frase \textit{"Everything is an Object"}, per la programmazione funzionale possiamo riassumerla con \textit{"Everything is a Function"}. Quando si parla di funzioni nel ambito della \ac{FP} si intendo \textbf{funzioni pure} cioè senza effetti collaterali. Per effetti collaterali si intende che la funzione fa altro oltre a restituire un risultato. Un paio di esempi, presi da \texttt{Functional Programming in Scala}, sono:

\begin{itemize}
    \item Modifica di una variabile
    \item Modifica del campo di un oggetto
    \item Leggere da o scrivere su un file
    \item "Disegnare" sullo schermo
\end{itemize}

Si potrebbe pensare che con l'uso della \ac{FP} si possano costruire solo programmi semplice, nella realtà non c'é alcuna limitazione sulla complessità del software da costruire poiché il paradigma della FP esprime un nuovo modo di pensare e scrivere il codice.

Nel dettaglio, per \textbf{funzione pura} si intende una funzione $f:A\to B$, (una funzione che prende un input di tipo $A$ e restituisce un output di tipo $B$) che mette in relazione ogni elemento di $A$ con esattamente un valore di $B$. Qualsiasi altra operazione che non sia utile a calcolare $f(a)=b$ con $a\in A$ e $b\in B$ deve essere intesa come effetto collaterale della funzione e quindi evitata se si vuole creare una funzione pura.

Un esempio di funzione pura, senza effetti collaterali, è la funzione di somma che prende in input due valori e ne restituisce la loro somma \cref{lst:sum-function}. 

\begin{lstlisting}[language=Scala, label={lst:sum-function}, caption={Esempio di funzione pura in Scala}]
    def sum(a: Int, b: Int): Int = a + b
\end{lstlisting}

Un esempio di funzione non pura, con effetti collaterali, è la funzione che prende in input un valore e lo stampa a schermo \cref{lst:print-function}.

\begin{lstlisting}[language=Scala, label={lst:print-function}, caption={Esempio di funzione non pura in Scala}]
    def print(a: Int): Unit = println(a)
\end{lstlisting}

Formalmente si può definire una funzione pura con il concetto di \ac{RT}:

\begin{quote}
    Una funzione $f$ è Referentially Transparent se per ogni contesto $C$ nel quale la funzione viene inserita, essa può essere sostituta dal risultato della stessa funzione $f$ senza condizionare il risultato di $C$.
\end{quote}

È proprio questa proprietà che permette ad un programma progettato con approccio funzionale di essere maggiormente scalabile e mantenibile.

\subsection{Sistemi collettivi ed eterogenei} 

Per comprendere il potenziale del paradigma dell'\ac{AP} è fondamentale definire quale tipo di problema si vuole risolvere. La crescita del mondo \ac{IoT} ha portato alla presenza di numerosi dispositivi connessi tra loro di ogni tipo e caratterizzati da protocolli di comunicazione eterogenei. Il mondo dell'IoT in continua evoluzione promette di migliore la produzione, gli spazi di lavoro e la sanità attraverso la raccolta e l'analisi di grandi quantità di dati. È nato di conseguenza il bisogno di progettare sistemi resistenti e resilienti che permettessero di gestire queste grandi quantità di dispositivi. È necessario che questi sistemi siano capaci di: adattarsi a cambiamenti imprevedibili, permettere l'implementazione di nuovi comportamenti, permettere una capacità di rilevazione e attuazione nel ambiente in modo distribuito e coordinato. Allo stato attuale della tecnologia è difficile progettare sistemi di questo tipo poiché non esistono framework che permettano di gestire in modo semplice e intuitivo la complessità di questi sistemi.

Un'astrazione grafico del mondo IoT è presente in \cref{fig:iot-arc}. È possibile comprendere come ci sia uno strato contente i nodi (dispositivi)\footnote{HMI: Human-Machine-Interaction.}, uno strato che rappresenta la rete (internet) mediante la quale comunicano\footnote{Prima di accedere alla rete internet le informazioni dei sensori vengono raccolte dai Edge Gateway che si occupano di instradare le informazioni.} ed uno strato contente il mondo Cloud dove vengono raccolte tutte le informazioni prodotte dai nodi della rete e computate attraverso applicazioni complesse per l'analisi, la pianificazione, l'ottimizzazione ed altri scopi.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/iot-arc.png}
    \caption{Architettura del mondo IoT}
    \label{fig:iot-arc}
\end{figure}

Il problema di questa architettura è che inviare queste ingenti quantità di dati da un numero elevato di nodi può avere effetti negati sui costi, le disponibilità, la scalabilità e la latenza delle comunicazioni. Una delle soluzione trovate è quella di spostare la computazione più vicino possibile ai nodi della rete, in modo da ridurre la quantità di dati da inviare e la latenza delle comunicazioni. Questo approccio è chiamato \textit{Edge Computing} non è sempre conveniente applicarlo, dipende dal contesto (non sarebbe adatto nel caso i nodi abbiamo specifiche tecniche, come memoria e capacità di calcolo, deboli). 

Nella progettazione di sistemi per il controllo di sistemi aggregati\footnote{Sistemi caratterizzati da un insieme di dispositivi che collaborano tra di loro per raggiungere un obiettivo comune.} si sottolinea la necessità di meccanismi che rendano possibile ed intuitivo il riutilizzo e la capacità di composizione dei componenti così da poter costruire API\footnote{Application Programming Interface} a più strati.

Ci sono diversi esempi di sistemi aggregati che necessitano di un controllo distribuito e coordinato, un esempio è il controllo di droni in formazione. In questo caso, ogni drone deve essere in grado di comunicare con i propri vicini per mantenere la formazione, evitare collisioni e raggiungere l'obiettivo comune\cref{fig:drones}. Un altro esempio è il controllo di un gruppo di robot che devono esplorare un ambiente sconosciuto con lo scopo di raccogliere informazioni.

\begin{figure}
    \centering
    \includegraphics[width=.7\linewidth]{figures/drones.jpg}
    \caption{Droni in formazione in ambiente notturno}
    \label{fig:drones}
\end{figure}

Per andare in contro a queste necessità nasce il paradigma dell'\ac{AP} che da la nascita al concetto di \textit{intelligenza collettiva}.

\subsection{Stato dell'arte}

Nei capitoli precedenti si è esaminata l'evoluzione dal paradigma \ac{OOP} a quello \ac{FP}, la quale, ha permesso di gestire in modo più pratico progetti più complessi e semplificandone la manutenibilità. Una ulteriore, più specifica, evoluzione è quella portata dal paradigma dell'\ac{AP}. Quest'ultimo mira a rendere la progettazione, manutenzione e testing nell'ambito del controllo di dispositivi hardware di larga-scala (anche conosciuti come \textbf{collective adaptive systems (CAS)}).

L'\ac{AC} si basa sulla mappatura di un mondo cyber-fisico in un diverso modello logico. Da un punto di vista strutturale possiamo vedere un sistema aggregato come una rete di dispositivi capaci di computare ed equipaggiati con (o sui quali è possibile equipaggiare) sensori ed attuatori, che corrispondono ai nodi. I nodi sono connessi tra loro secondo una logica di vicinato, che può essere definita in base alla distanza fisica o alla comunicazione. Da un punto di vista comportamentale, invece, ogni nodo interpreta il programma aggregato solo in relazione al proprio contesto locale. Da un punto di vista delle interazioni, i nodi estraggono informazione dal proprio vicinato e propagano le proprie nello stesso contesto. Queste interazioni son ciò che permettono al contesto locale e globale di influenzarsi reciprocamente.

La tecnica dell'\ac{AP} si basa su 3 principi fondamentali per la costruzione di sistemi robusti e resilienti:

\begin{itemize}
    \item I dettagli implementativi dei sistemi hardware che si vuole andare a manipolare devono essere nascosti così da permettere ai programmatori di concentrarsi solo sulla logica di alto livello del sistema, in alcuni casi è possibile che questa astrazione delle specifiche di basso livello sia tale da poter essere pensato come uno spazio continuo, invece di un insieme di dispositivi separati. Per esempio, invece di immaginarci una stanza piena di sensori, la trattiamo come una area unificata definita da un flusso continuo di dati.
    \item Il programma manipola le strutture dati della rete di dispositivi sia in funzione della loro estensione spaziale che di quella temporale. Approccio particolare utile in sistemi in cui l'informazione cambia in base al luogo.
    \item Ogni dispositivo della rete esegue le operazioni necessarie in autonomia, coordinandosi con i dispositivi vicini attraverso meccanismi robusti e resilienti. In questo modo il sistema rimane fluido ed efficiente anche in situazioni anomale, ad esempio causate dal guasto di un qualche dispositivo.
\end{itemize}

L'approccio \ac{AP} nella progettazione di sistemi è profondamente diverso classico approccio "dispositivo centrico".
Nel secondo caso, ogni dispositivo della rete ha il compito di compiere tutte le operazioni richieste per il raggiungimento della soluzione e simultaneamente comunicare con gli altri dispositivi della rete. Questo approccio, seppur semplice, è poco scalabile e difficile da mantenere al crescere della complessità del sistema. 
Il nuovo paradigma, invece, prevede la scomposizione in componenti del programma assegnato ad ogni dispositivo, ogni componente esegue un compito specifico e comunica principalmente solo con i componenti dello stesso tipo presenti nel suo intorno per eseguire un servizio ed eventualmente con un altro componente presente nello stesso dispositivo al fine di realizzare una nuova soluzione inerente ad un'altro servizio. Le componenti sono una astrazioni dei \textit{campi di calcolo}.

Il paradigma \ac{AP}, il quale ha permesso la creazione di framework come ScaFi, Protelis e MacroSwarm, si basa sul concetto dei sopracitati \textit{campi di calcolo}. Per \textit{campo di calcolo} o \textit{computationals field} si intende la mappatura degli elementi del dominio in cui si opera in un insieme di valori.
I campi di calcolo vengono utilizzati per standardizzare le interazioni tra i dispositivi, permettendo di analizzare e progettare sistemi distribuiti in modo più semplice e intuitivo. L'idea di campo prende ispirazione dai campi fisici, ad esempio quello magnetico. Ogni dispositivo della rete è considerato come un punto nello spazio ed il campo rappresenta un dato valore assegnato ad ognuno di questi punti. L'insieme di tutti i valori, che chiameremo \textit{campi} o \textit{fields} rappresentano lo stato di un sistema in un dato istante.

Questo approccio è generalmente utilizzato per un controllo prolungato dei dispositivi della rete sulla quale si vogliono eseguire task che necessitano di eseguire un gran numero di rilevazioni (ad esempio utilizzando sensori), computazioni ed attuazioni.

Ogni dispositivo del proprio sistema aggregato esegue una computazione in modo asincrono attraverso i \textbf{sense-compute-(inter)act rounds}\label{sec:sense-compute-interact}, ogni round è composto da tre fasi concettuali:

\begin{enumerate}
    \item \textbf{Aggiornamento del contesto (sense)}: ogni nodo memorizza il suo stato precedente, i dati ambientali restituiti da eventuali sensori e le più recenti informazioni ricevute dai nodi vicini.
    \item \textbf{Esecuzione del Programma Aggregato (compute)}: il campo di ogni nodo viene computato in base al contesto locale e produce un valore di output detto \textit{export} da condividere con il proprio vicinato ed un output utile per l'attuazione.
    \item \textbf{Azione (inter-act)}: in questa fase il nodo effettua le seguenti azioni:
    \begin{enumerate}
        \item \textbf{Condivisione}: il nodo condivide il proprio \textit{export} verso i nodi del suo vicinato in formato broadcast
        \item \textbf{Controllo di attuatori}: l'output del nodo viene 
        utilizzato per l'esecuzione di uno o più attuatori nel proprio ambiente
    \end{enumerate}
\end{enumerate}


Posizionandoci in un livello più implementativo troviamo i seguenti costrutti per la manipolazione dei campi: 
% //TODO: citare il paper "Aggregate Programming for the Internet of Things" per i seguenti costrutti

\begin{itemize}
    \item \textbf{Functions}: funzioni $$ b(e_1,\dots,e_n) $$ applicate agli argomenti $e_1,\dots,e_n$. Possono essere sia funzioni matematiche, logiche o algoritmiche ma possono anche rappresentare sensori o attuatori.
    \item \textbf{Dynamics}: $$ rep(x \leftarrow v){s_1;\dots;s_n} $$ rappresenta un una variabile di stato locale $x$, inizialmente inizializzata con il valore $v$ e che può essere modificata dalle istruzioni $s_1,\dots,s_n$. In questo modo si definisce un campo dinamico.
    \item \textbf{Interaction}: $$ nbr(s) $$ rappresenta il vicinato di un dispositivo, ovvero l'insieme dei dispositivi con cui è possibile interagire.
    \item \textbf{Restrictions}: $$
        \begin{array}{l}
        \text{if } e \\
        \qquad s_1; \quad \dots \quad s_n; \\
        \text{else} \\
        \qquad s_1'; \quad \dots \quad s_m';
        \end{array}
    $$
    permette di andare a definire sotto spazio del campo principiale in base ad una condizione $e$ sul quale poi andare ad eseguire certe istruzioni invece di altre. È importante che le istruzioni riferite ad un certo sotto spazio non abbiano effetti su altri sotto spazi.
\end{itemize}

\begin{quote}
    \centering
    Come viene eseguito un modello di \ac{AP}?
\end{quote}

Questo paradigma, proprio come quelli precedenti, non è privo di difetti. 
Implementazioni di questo tipo sono difficili da integrare in sistemi programmati in modo più tradizionale, inoltre, dal punto di vista della programmazione sono mancanti i meccanismi per la gestione della concorrenza e della computazione dinamica dei campi. Il framework ScaFi, che vedremo nel prossimo capitolo, cerca di risolvere questi problemi.

% //TODO: capitolo incompleto

\section{ScaFi}

ScaFi è un toolkit open-source basato su Scala per l'\ac{AC} per la progettazione ad alto livello di sistemi aggregati.
Il termine ScaFi deriva dalla unione di Scala e Fields. Scala è un linguaggio java-like moderno e flessibile progettato per unificare il paradigma \ac{OOP} e quello \ac{FP}. È stato progettato per essere coinciso e facilmente leggibile, inoltre si basa sulla Java Virtual Machine, la quale permette l'utilizzo delle librerie Java. L'utilizzo della JVM e la flessibilità del linguaggio sono state le caratteristiche chiave per il raggiungimento della popolarità di questo linguaggio. Il termine Field invece deriva dai \textit{field calculus} (campi di calcolo) di cui abbiamo parlato nei capitoli precedenti.

L'Architettura di ScaFi è riassumibile nella immagine \cref{fig:scafi-arc}.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/scafi-arc.jpg}
    \caption{Architettura del framework ScaFi}
    \label{fig:scafi-arc}
\end{figure}

Ispezionando la figura, troviamo:

\begin{itemize}
    \item \textbf{scafi-commons}: fornisce le entità di base, ad esempio astrazioni temporali e spaziali
    \item \textbf{scafi-core}: rappresenta il core del framework fornendo il DSL\footnote{Domain Specific Language: linguaggio di programmazione progettato specificamente per risolvere problemi o esprimere concetti di un dominio ristretto. Il DSL di ScaFi (libreria di programmazione) è quindi un linguaggio specifico per creare e valutare programmi di tipo aggregato, utilizzando una sintassi e una semantica pensate appositamente per questo tipo di calcoli e simulazioni.} per la progettazione di sistemi aggregati; con il supporto di librerie standard.
    \item \textbf{scafi-stdlib-ext}: librerie extra
    \item \textbf{scafi-simulator}: fornisce un supporto per la simulazione dei sistemi di \ac{AP} sviluppati
    \item \textbf{scafi-simulator-GUI}: fornisce un'interfaccia grafica per la simulazione
    \item \textbf{spala}: ("spatial scala") si tratta di un \textit{middleware} che permette di eseguire programmi \ac{AC} basati sugli attori ed è indipendente dal DSL di ScaFi
    \item \textbf{scafi-distributed}: layer integrativo per l'utilizzo di \textbf{spala} in ScaFi
\end{itemize}

\begin{quote}
    \centering
    Perché usare Scala?
\end{quote}

Il motivo per cui Scala è un linguaggio particolarmente adatto per la programmazione di sistemi di \ac{AC} è dovuto proprio alla sua flessibilità, essa permette di lavorare sui campi di calcolo, che necessitano di essere supportati dalle seguenti proprietà, in modo molto naturale:

\begin{itemize}
    \item una sintassi coincisa per definire funzioni sui campi, le quali in Scala sono le espressioni standard
    \item meccanismi di controllo sul \textit{quando} e \textit{come} le espressioni vengono valutate
    \item capacità di calcolare lo stato di un campo basandosi sulle informazioni più recenti dei nodi presenti nel suo intorno
\end{itemize}

In Scala ogni valore è un oggetto ed i comportamenti vengono definiti attraverso i metodi. Per implementare un campo di calcolo in Scala andremo a definire gli operato dei campi attraverso la definizione di metodi che verranno interpretati dagli oggetti sui quali sono stati chiamati. Gli oggetti, in questo modo, possono essere visti come macchine virtuali in locale per l'esecuzione degli operatori di campo.

Di seguito l'interfaccia fondamentale per la definizione di un campo di calcolo in Scala (\cref{lst:constructs-scala}):

\lstinputlisting[float=tb,language=Scala,label={lst:constructs-scala},caption={Interfaccia per la definizione di un campo di calcolo in Scala}]{listings/Constructs.scala}

Gli elementi principali di questa interfaccia sono:
\begin{itemize}
    \item \verb|rep(init)(f)| cattura l'evoluzione di stato di un valore inizializzato ad \verb|init| e aggiornato ad ogni round con la funzione \verb|f|
    \item \verb|nbr(expr)|: rileva le comunicazioni relative al valore computato dalla espressione \verb|expr| dei nodi vicini
    \item \verb|foldhood(init)(acc)(expr)|: si occupa, partendo da un valore iniziale \verb|init|, di accumulare i valori computati dai nodi vicini attraverso la funzione di accumulazione \verb|acc| e settare i valori computati dalla espressione \verb|expr| verso i propri vicini
    \item \verb|branch(cond)(th)(el)|: cattura una partizione (spazio-temporale) del dominio in base alla condizione \verb|cond|, se questa è rispettata esegue l'espressione \verb|th| altrimenti \verb|el|
    \item \verb|mid|: provvede ad identificare un certo nodo
    \item \verb|sense(sensorName)|: permette di accedere (ad alto livello) al sensore locale \verb|sensorName|
    \item \verb|nbrvar(sensorName)|: permette di accedere (ad alto livello) ai sensori dei nodi vicini, simile ad \verb|nbr| ma valido per sensori forniti dalla piattaforma, questi sensori forniscono un valore per ciascun vicino
\end{itemize}

In ScaFi, i campi non sono reificati esplicitamente ma esistono solo a livello semantico, questo significa che un'espressione Scala non viene gestita come un'espressione di campo finché non viene passata all'interprete ScaFi.
% //TODO: citare la tesi PhD di Casadei

ScaFi fornisce alcuni operatori, detti anche \textit{blocchi}, di alto livello già implementati tipici dei sistemi aggregati:

\begin{itemize}
    \item \textbf{Sparse choice (definizione di un leader)}: Blocco 
    \begin{center}
        \verb|S(grain: Double):Boolean|
    \end{center}
    produce un campo booleano auto organizzato che definisce a \verb|true| un insieme sparso di dispositivi distanziati tra di loro di almeno \verb|grain|
    \item \textbf{Gradient-cast (propagazione distribuita)}: Blocco 
    \begin{center}
        \verb|G[T](source: Boolean, value: T, acc: T=>T): T|
    \end{center}
    utilizzato per propagare un valore \verb|value| da una sorgente \verb|source| a tutti i nodi della rete, in ordine di distanza crescente, seguendo un gradiente che modifica i valori di ogni nodo secondo una funzione di accumulo \verb|acc|
    \item \textbf{Collect-cast (collezione distribuita)}: Blocco 
    \begin{center}
        \verb|C[T](sink: Boolean, value: T, acc(T,T)=>T): T| 
    \end{center}
    utilizzata per riassumere le informazioni distribuite in un unico dispositivo \verb|sink|, i valori \verb|values| prodotti dai dispositivi vengono "raccolti" dal gradiente che si muove in direzione di \verb|sink| e vengono accumulati secondo la funzione di accumulo \verb|acc|
\end{itemize}

\section{Macroswarm}

Macroswarm è un framework per la programmazione di sistemi di robotica distribuita basato su ScaFi e che estende lo stesso ScaFi. Macroswarm nasce con l'avanzare delle tecnologie ed il crescente interesse verso il controllo di flotte di dispositivi come droni, robot, veicoli o folle di persone definite da dispositivi portatili/indossabili in modo.
Si è voluto, quindi, creare un framework che permettesse di programmare sistemi distribuiti di robot in modo semplice ed intuitivo secondo degli \textit{swarm behavior}\footnote{Comportamenti di sciame/flotta}, permettendo di concentrarsi solo sulla logica di alto livello del sistema. Questo framework è stato scelto per il progetto in esamina.
Il paradigma \ac{AP} e di conseguenza ScaFi sono state scelte naturali per la progettazione di tale framework (\cref{fig:macro-swarm-arc}).

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/macroSwarm-arc.pdf}
    \caption{Architettura di Macroswarm}
    \label{fig:macro-swarm-arc}
\end{figure}

Fondamentalmente, Macroswarm è un programma ScaFi il quale esegue un certo programma aggregato su una certa piattaforma. L'idea è quella di creare una rappresentazione astratta di una flotta di dispositivi attraverso campi di calcolo, tipicamente vettori.
All'intero del Framework troviamo le API per progettazione dei sistemi aggregati su sistemi fisici (i rettangoli bianchi in \cref{fig:macro-swarm-int} rappresentano i moduli principali).

\begin{figure}
    \centering
    \includegraphics[width=.99\linewidth]{figures/macroSwarm-modeles.pdf}
    \caption{Struttura di Macroswarm e moduli interni}
    \label{fig:macro-swarm-int}
\end{figure}

È rilevante notare che in Macroswarm la computazione della attuazione da eseguire su un certo dispositivo e la reale attuazione nel mondo reale sono disaccoppiate. Il motivo di questa scelta è dovuto al fatto che ad ogni round\cref{sec:sense-compute-interact} il programma aggregato può variare un qualche parametro per completare il task. È, comunque, possibile scegliere quale modalità di computazione-attuazione scegliere poiché, in base al contesto, una può essere più adatta dell'altra. Le modalità sono:
\begin{itemize}
    \item \textbf{round-based}: è possibile eseguire l'attuazione al termine del prossimo round
    \item \textbf{long-standing}: l'attuazione che si vuole eseguire è valida finché non viene revisionata o ritirata
\end{itemize}



% //TODO: completare la Macroswarm section con la descrizione dei moduli


\section{Thymio e tdmclient}

\begin{quote}
    "Thymio è un robot educativo open-source progettato da ricercatori dell'EPFL (Politecnico federale di Losanna), in collaborazione con l'ECAL (Università d'arte e design di Losanna), e prodotto da Mobsya, un'associazione no-profit la cui missione è quella di offrire percorsi STEAM completi e coinvolgenti a studenti di tutte le età."
    \begin{flushright}
        \textit{-- \href{https://www.thymio.org/}{Mobsya}}
    \end{flushright}
\end{quote}

\begin{figure}
    \centering
    \includegraphics[width=.7\linewidth]{figures/thymio.png}
    \caption{Robot Thymio}
    \label{fig:interpreter-vs-compiler-robot}
\end{figure}

Thymio è un robot programmabile con un'ampia varietà di sensori e attuatori, tra cui:
\begin{itemize}
    \item 9 sensori a infrarossi (portata circa 10 cm)
    \item 5 pulsanti a sfioramento (tecnologia capacitiva)
    \item 1 accelerometro a tre assi
    \item 1 termometro
    \item 1 microfono
    \item 1 ricevitore a infrarossi per il telecomando
    \item 39 LED controllabili
    \item 2 motori DC collegati alle ruote
    \item 1 altoparlante
\end{itemize}

Il deploy del codice sul robot Thymio avviene tramite un radio dongle USB.
\paragraph{Thymio Network}: La connessione wireless dei robot è basata sul protocollo \href{https://en.wikipedia.org/wiki/IEEE_802.15.4}{802.15.4} in banda con frequenza 2.4 GHz. Questo protocollo permette di gestire una rete con molti nodi a discapito del rispetto delle seguenti condizioni:

\begin{itemize}
    \item tutti i nodi devono trovarsi tutti nello stesso canale radio (sono disponibili 3 reti: [0, 1, 2])
    \item tutti i dispositivi devono avere lo stesso Identificativo di rete (PAN ID)
    \item tutti devono avere un nodo Identificativo univo (nodeID)
\end{itemize}

Questo protocollo è stato scelto per la sua bassa potenza e la sua affidabilità. Il protocollo è stato implementato in modo da permettere la comunicazione tra i robot e con il computer tramite il dongle USB.

Il dispositivo è stato scelto per essere implementato nella demo per la notte dei ricercatori in quanto è un robot molto versatile e adatto a molteplici applicazioni. Inoltre, il robot è molto diffuso nelle scuole e nei laboratori di robotica educativa, quindi è un'ottima scelta per mostrare il potenziale di ScaFi in un contesto educativo.

Questo piccolo robot nasce per essere programmato con linguaggi a blocchi come VPL, VPL3, Scratch, Blocky e non come Aseba, Python e Ros, tutti accessibili dalla suite dedicata \textit{"Thymio Suite"}.
% //TODO: citare doc a tutti i linguaggi supportati dalla bibliografia
Noi ci concentreremo nel uso di Python. 

% //TODO: da scrivere meglio
Python a differenza di altri linguaggi (ad esempio C/C++) è interpretato e non compilato. I linguaggi compilati prevedono la conversione del programma scritto in un linguaggio ad alto livello in linguaggio macchina per poi farlo eseguire dal processore, occorre quindi compilare il sorgente ad ogni nuova modifica per poi re-eseguirlo. Python, invece, è un linguaggio interpretato, il codice sorgente viene eseguito direttamente dal programma interprete, il quale esegue ogni comando riga per riga.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/interpreter-compiler.pdf}
    \caption{Interprete vs Compilatore}
    \label{fig:interpreter-vs-compiler}
\end{figure}

Nel caso del robot Thymio, non è presente un interprete nel suo microcontrollore. È presente, invece, una Aseba Virtual Machine che permette di eseguire programmi scritti in linguaggio Aseba. 

Aseba è un linguaggio di programmazione ad alto livello basato su architettura ad eventi, il che significa che gli eventi sono eseguiti in modo asincrono. Gli eventi sono identificati da un Identificativo ed opzionalmente da un \textit{payload} (dati aggiuntivi). 
Gli eventi possono essere di due tipi:
\begin{itemize}
    \item \textbf{global events}: eventi generati dai nodi e condivisi con la rete
    \item \textbf{local events}: eventi generati da un nodo e non condivisi con la rete (ad esempio un evento generato da un sensore dello stesso nodo)
\end{itemize}

Un esempio di codice Aseba è il seguente \cref{lst:aseba-code}.
% Non è disponibile Aseba quindi useremo Python
\begin{lstlisting}[language=Python, label={lst:aseba-code}, caption={Esempio di codice Aseba con eventi}]
    var state

    callsub init  # Inizializza il programma

    sub init
        state = 0
        call leds.bottom.left(0,0,32)
        call leds.bottom.right(0,32,0)
        call leds.top(32,0,0)

    # Re-inizia quando il pulsante centrale viene premuto
    onevent button.center
        callsub init
\end{lstlisting}

Il \textbf{Thymio Device Manager} è una delle feature della Thymio Suite, si occupa di gestire la rete dei Thymio. Inoltre ha il compito di tradurre il sorgente, scritto dall'utente, da linguaggio Aseba ad Aseba bytecode per poi eseguire il \textit{deploy} sul robot. Per l'utilizzo di Python, invece, è necessario l'utilizzo del modulo \textbf{tdmclient} che si occupa di far comunicare Python con il \ac{TDM} \cref{fig:tdmclient}. È necessario che la Thymio Suite sia in esecuzione per poter utilizzare il modulo \textbf{tdmclient}, il quale, a sua volta, necessita dell'utilizzo di \textbf{Python 3} come interprete.

Questo modulo permette di:
\begin{itemize}
    \item accedere alle variabili, sensori, attuatori del robot
    \item convertire uno script Python in un script Aseba (transpiler)
    \item inviare codice Aseba al \ac{TDM} che a sua volta invia il relativo bytecode al  robot Thymio 
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/TDM.pdf}
    \caption{Tdmclient workflow}
    \label{fig:tdmclient}
\end{figure}

Le possibilità offerte da questo modulo sono molteplici, ad esempio è possibile inviare comandi direttamente ad un robot Thymio da terminale:

\begin{lstlisting}[language=Bash, label={lst:command-to-thymio}, caption={Esempio di invio di comando (foo) ad un robot Thymio}]
    python3 -m tdmclient sendevent --event foo --data 123
\end{lstlisting}

In \cref{lst:command-to-thymio} si assume che il robot accetti un evento di nome \textit{foo} con un payload di tipo intero e che il robot sia in ascolto di eventi (\textit{unlocked}). Per metter in ascolto un robot di un certo evento è necessario andare ad inserire una vista su quel determinato robot dalla Thymio Suite.

\begin{lstlisting}[language=Python, label={lst:thymio-catch-event}, caption={Esempio di programma interno a Thymio per la ricezione di eventi (foo)}]
    var x

    onevent foo
        x = event.args[0]
\end{lstlisting}

Il modulo permette di eseguire il transpile (conversione) di un programma Python in Aseba. Per farlo è necessario utilizzare il comando \textit{transpile} del modulo \textbf{tdmclient}:

\begin{lstlisting}[language=Bash, label={lst:transpile-python-to-aseba}, caption={Esempio di transpile di un programma Python (print.py) in Aseba}]
    python3 -m tdmclient transpile examples/print.py
\end{lstlisting}

Utilizzando il modulo aggiuntivo \verb|ClientAsync| è possibile modificare le variabili dei robot Thymio attraverso chiamate asincrone in uno script \textbf{Python}.
Si andrà ad esaminare ulteriormente questa feature di \textbf{tdmclient} nel capitolo \cref{chap:design} e \cref{chap:implementazione} poiché è ciò che si è utilizzato per la progettazione del nostro sistema.

\section{Aruco Tag}

Gli Aruco marker sono tag quadrati che possono essere rilevati da una camera. Ogni tag è una matrice $4 \times 4$ ed ha un codice (intero) univoco associato che può essere rilevato da un algoritmo di visione artificiale\cref{fig:aruco-markers}. È rilevante notare che la matrice di ogni Aruco marker corrisponde ad uno stesso codice per ogni sua versione trasposta. 
Questi tag sono molto utili per la localizzazione e la navigazione di robot autonomi. Sarà questo strumento che verrà utilizzato per la demo della notte dei ricercatori per la localizzazione e calcolo della direzione dei robot Thymio.

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{figures/aruco-markers.png}
    \caption{Aruco markers identificati da un algoritmo di visione artificiale}
    \label{fig:aruco-markers}
\end{figure}

Questo strumento è già presente nel sistema in questione.

%----------------------------------------------------------------------------------------
\chapter{Analisi}
\label{chap:analisi}
%----------------------------------------------------------------------------------------

\section{Estensibilità del sistema ad un nuovo modello di Robot (Thymio)}

\section{Gestione dei vincoli di compatibilità del sistema Thymio}


%----------------------------------------------------------------------------------------
\chapter{Design}
\label{chap:design}
%----------------------------------------------------------------------------------------

\section{Architettura server Flask}

\section{File di configurazione}

%----------------------------------------------------------------------------------------
\chapter{Implementazione}
\label{chap:implementazione}
%----------------------------------------------------------------------------------------

\section{Implementazione del server Flask}

\section{Esempi di Algoritmi AP applicati ai Robot Wave e Thymio nello stesso ambiente}

You may also put some code snippet (which is NOT float by default), eg: \cref{lst:random-code}.

\lstinputlisting[float,language=Java,label={lst:random-code}]{listings/HelloWorld.java}

\section{Fancy formulas here}

%----------------------------------------------------------------------------------------
\chapter{Conclusione}
\label{chap:conclusione}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter

\nocite{*} % Remove this as soon as you have the first citation

\bibliographystyle{alpha}
\bibliography{bibliography}

\begin{acknowledgements} % this is optional
Optional. Max 1 page.
\end{acknowledgements}

\end{document}
